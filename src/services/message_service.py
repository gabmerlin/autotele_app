"""
Service de gestion des messages programm√©s avec rate limiting global strict.
"""
import asyncio
import random
import time
from datetime import datetime
from typing import List, Dict, Tuple, Optional, Set
from pathlib import Path
from collections import deque
from contextlib import asynccontextmanager

from core.telegram.account import TelegramAccount
from utils.logger import get_logger
from utils.constants import (
    TELEGRAM_GLOBAL_RATE_LIMIT,
    TELEGRAM_SAFETY_MARGIN
)

logger = get_logger()


class GlobalRateLimiter:
    """
    Rate limiter global adaptatif avec attente non-bloquante.
    S'adapte automatiquement apr√®s un FloodWait pour √©viter les r√©p√©titions.
    """
    
    def __init__(self):
        self._lock = None
        self._active_accounts = set()
        self._last_request_time = 0.0
        
        # Limite globale fixe
        self._global_rate_limit = TELEGRAM_GLOBAL_RATE_LIMIT * TELEGRAM_SAFETY_MARGIN
        self._min_delay = 1.0 / self._global_rate_limit
        
        # üß† Syst√®me adaptatif par compte
        self._account_flood_counts: Dict[str, int] = {}  # Nombre de floods
        self._account_penalty_multipliers: Dict[str, float] = {}  # 1.0 = normal, 2.0 = 2√ó plus lent
        self._account_successful_since_flood: Dict[str, int] = {}  # Compteur de succ√®s
        self._recovery_threshold = 50  # Nombre de succ√®s avant r√©cup√©ration partielle
        
        logger.info(
            f"üîí Rate limiter adaptatif: {self._global_rate_limit:.1f} req/s "
            f"(d√©lai min: {self._min_delay*1000:.0f}ms) | "
            f"üß† Ajustement automatique apr√®s flood"
        )
    
    def _get_lock(self):
        """Cr√©e ou r√©cup√®re le lock global."""
        if self._lock is None:
            self._lock = asyncio.Lock()
        return self._lock
    
    def register_account(self, account_id: str):
        """Enregistre un compte comme actif."""
        self._active_accounts.add(account_id)
        
        # Initialiser les compteurs adaptatifs pour ce compte
        if account_id not in self._account_flood_counts:
            self._account_flood_counts[account_id] = 0
            self._account_penalty_multipliers[account_id] = 1.0
            self._account_successful_since_flood[account_id] = 0
        
        nb = len(self._active_accounts)
        rate_per_account = self._global_rate_limit / nb if nb > 0 else self._global_rate_limit
        penalty = self._account_penalty_multipliers[account_id]
        effective_rate = rate_per_account / penalty
    
    def unregister_account(self, account_id: str):
        """D√©senregistre un compte."""
        self._active_accounts.discard(account_id)
    
    def report_flood(self, account_id: str):
        """
        Signale qu'un FloodWait a √©t√© d√©tect√© pour ce compte.
        Ralentit automatiquement le d√©bit pour √©viter les r√©p√©titions.
        """
        self._account_flood_counts[account_id] = self._account_flood_counts.get(account_id, 0) + 1
        old_penalty = self._account_penalty_multipliers.get(account_id, 1.0)
        
        # Augmenter la p√©nalit√© : multiplier par 1.5 √† chaque flood (max 4.0)
        new_penalty = min(old_penalty * 1.5, 4.0)
        self._account_penalty_multipliers[account_id] = new_penalty
        self._account_successful_since_flood[account_id] = 0
        
        new_rate = self._global_rate_limit / new_penalty
        logger.warning(
            f"üß† FloodWait #{self._account_flood_counts[account_id]} d√©tect√© ‚Üí "
            f"D√©bit r√©duit: {new_rate:.1f} req/s (p√©nalit√© √ó{new_penalty:.1f})"
        )
    
    def report_success(self, account_id: str):
        """
        Signale un envoi r√©ussi. R√©cup√®re progressivement le d√©bit normal.
        """
        if account_id not in self._account_successful_since_flood:
            return
        
        self._account_successful_since_flood[account_id] += 1
        successes = self._account_successful_since_flood[account_id]
        penalty = self._account_penalty_multipliers.get(account_id, 1.0)
        
        # R√©cup√©ration progressive : tous les 50 succ√®s, r√©duire la p√©nalit√© de 20%
        if successes >= self._recovery_threshold and penalty > 1.0:
            new_penalty = max(penalty * 0.8, 1.0)  # R√©duire de 20%, min 1.0
            self._account_penalty_multipliers[account_id] = new_penalty
            self._account_successful_since_flood[account_id] = 0
            
    
    async def _calculate_wait_time(self, account_id: str) -> float:
        """Calcule le temps d'attente n√©cessaire avec p√©nalit√© adaptative (thread-safe)."""
        async with self._get_lock():
            # Appliquer le multiplicateur de p√©nalit√© pour ce compte
            penalty = self._account_penalty_multipliers.get(account_id, 1.0)
            adjusted_delay = self._min_delay * penalty
            
            now = time.time()
            if self._last_request_time > 0:
                elapsed = now - self._last_request_time
                if elapsed < adjusted_delay:
                    return adjusted_delay - elapsed
            return 0.0
    
    @asynccontextmanager
    async def request_slot(self, account_id: str):
        """
        Context manager pour acqu√©rir un slot de requ√™te avec ajustement adaptatif.
        Les attentes se font EN DEHORS du lock pour ne pas bloquer les autres comptes.
        
        Usage:
            async with rate_limiter.request_slot(account_id):
                await account.schedule_message(...)
        """
        # ‚úÖ Calculer et attendre EN DEHORS du lock (avec p√©nalit√© adaptative)
        wait_time = await self._calculate_wait_time(account_id)
        if wait_time > 0:
            await asyncio.sleep(wait_time)
        
        # ‚úÖ Lock tr√®s court juste pour marquer le slot
        async with self._get_lock():
            self._last_request_time = time.time()
        
        # ‚úÖ L'envoi se fait en parall√®le avec les autres comptes
        try:
            yield
        finally:
            # Mettre √† jour le timestamp final (optionnel, d√©j√† fait avant)
            pass


# Instance globale
_rate_limiter = GlobalRateLimiter()


class MessageService:
    """Service pour g√©rer l'envoi de messages programm√©s."""
    
    @staticmethod
    async def send_scheduled_messages(
        account: TelegramAccount,
        group_ids: List[int],
        message: str,
        dates: List[datetime],
        file_path: Optional[str] = None,
        on_progress: Optional[callable] = None,
        cancelled_flag: Optional[Dict] = None,
        task: Optional['SendingTask'] = None
    ) -> Tuple[int, int, Set[int]]:
        """
        Envoie des messages programm√©s avec rate limiting global strict.
        
        Args:
            account: Compte Telegram √† utiliser
            group_ids: Liste des IDs de groupes
            message: Message √† envoyer
            dates: Liste des dates de planification
            file_path: Chemin du fichier √† joindre (optionnel)
            on_progress: Callback pour suivre la progression
            cancelled_flag: Dict avec une cl√© 'value' pour annuler l'envoi
            task: T√¢che d'envoi (optionnel, pour afficher les attentes FloodWait)
            
        Returns:
            Tuple[int, int, Set[int]]: (nb_envoy√©s, nb_skipped, groupes_en_erreur)
        """
        if not account.is_connected:
            raise ValueError("Le compte n'est pas connect√©")
        
        account_id = account.session_id
        _rate_limiter.register_account(account_id)
        
        # ‚úÖ D√©marrer le chronom√®tre pour les m√©triques de performance
        start_time = time.time()
        
        try:
            total_groups = len(group_ids)
            total_dates = len(dates)
            initial_total = total_groups * total_dates
            total = initial_total
            sent = 0
            skipped = 0
            failed_groups: Set[int] = set()
            
            # ‚úÖ Pr√©-remplir le cache d'entit√©s pour √©viter les cache miss pendant l'envoi
            cache_filled = 0
            for group_id in group_ids:
                if group_id not in account._entity_cache:
                    try:
                        entity = await account.client.get_input_entity(group_id)
                        account._entity_cache[group_id] = entity
                        cache_filled += 1
                        # Petit d√©lai pour ne pas surcharger l'API
                        if cache_filled % 10 == 0:
                            await asyncio.sleep(0.1)
                    except Exception as e:
                        pass
            
            # Upload du fichier UNE SEULE FOIS si n√©cessaire
            uploaded_file = None
            if file_path and Path(file_path).exists():
                try:
                    async with _rate_limiter.request_slot(account_id):
                        import mimetypes
                        from telethon.tl.types import (
                            InputMediaUploadedDocument, 
                            DocumentAttributeFilename
                        )
                        
                        # Upload du fichier
                        file_input = await account.client.upload_file(file_path)
                        
                        # D√©terminer le type MIME
                        mime_type = mimetypes.guess_type(file_path)[0] or 'application/octet-stream'
                        
                        # Cr√©er les attributs (nom du fichier)
                        file_name = Path(file_path).name
                        attributes = [DocumentAttributeFilename(file_name=file_name)]
                        
                        # Cr√©er le m√©dia upload√© correctement
                        uploaded_file = InputMediaUploadedDocument(
                            file=file_input,
                            mime_type=mime_type,
                            attributes=attributes
                        )
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è √âchec upload: {e}")
                    uploaded_file = None
            
            # ‚úÖ Cr√©er toutes les paires (date, groupe) et les randomiser
            # Cela √©vite la d√©tection de pattern de spam par Telegram
            schedule_pairs = [(dt, group_id) for dt in dates for group_id in group_ids]
            random.shuffle(schedule_pairs)
            
            # Parcourir les paires dans l'ordre randomis√©
            for idx, (dt, group_id) in enumerate(schedule_pairs, 1):
                if cancelled_flag and cancelled_flag.get('value'):
                    break
                
                # Skip les groupes qui ont d√©j√† √©chou√©
                if group_id in failed_groups:
                    skipped += 1
                    if on_progress:
                        on_progress(sent, total, skipped, failed_groups)
                    continue
                
                try:
                    # Acqu√©rir le slot et envoyer (atomique)
                    async with _rate_limiter.request_slot(account_id):
                        # ‚úÖ Si fichier upload√©, l'utiliser ; sinon utiliser le chemin direct
                        success, error = await account.schedule_message(
                            group_id,
                            message,
                            dt,
                            file_path=None if uploaded_file else file_path,
                            uploaded_file=uploaded_file
                        )
                    # ‚úÖ Le timestamp est automatiquement enregistr√© √† la sortie du context manager
                    
                    if success:
                        sent += 1
                        # üß† Signaler le succ√®s pour r√©cup√©ration adaptative
                        _rate_limiter.report_success(account_id)
                        if on_progress:
                            on_progress(sent, total, skipped, failed_groups)
                    else:
                        # G√©rer les erreurs
                        if MessageService._is_permission_error(error):
                            if group_id not in failed_groups:
                                failed_groups.add(group_id)
                                # ‚úÖ Calculer combien de messages restants pour ce groupe
                                remaining_for_group = sum(1 for _, gid in schedule_pairs[idx:] if gid == group_id)
                                total -= remaining_for_group
                                logger.warning(
                                    f"Groupe {group_id} exclu: {error} ({remaining_for_group} msg restants retir√©s)"
                                )
                            skipped += 1
                        elif MessageService._is_flood_error(error):
                            # üß† Signaler le flood pour ajustement adaptatif
                            _rate_limiter.report_flood(account_id)
                            
                            # Flood: attendre et r√©essayer
                            wait_time = MessageService._extract_wait_time(error)
                            logger.warning(f"üö® Flood: attente {wait_time}s...")
                            
                            # ‚è∞ Signaler l'attente √† la t√¢che (pour affichage UI)
                            if task:
                                task.set_waiting(wait_time + 2)  # +2s marge de s√©curit√©
                            
                            await asyncio.sleep(wait_time)
                            
                            # R√©essayer avec marge de s√©curit√© suppl√©mentaire
                            await asyncio.sleep(2.0)  # +2s de s√©curit√©
                            
                            # ‚úÖ Effacer l'attente (reprise)
                            if task:
                                task.clear_waiting()
                            
                            async with _rate_limiter.request_slot(account_id):
                                success, retry_error = await account.schedule_message(
                                    group_id, message, dt, 
                                    file_path=None if uploaded_file else file_path,
                                    uploaded_file=uploaded_file
                                )
                            
                            if success:
                                sent += 1
                                _rate_limiter.report_success(account_id)
                            else:
                                failed_groups.add(group_id)
                                skipped += 1
                                logger.error(f"‚ùå R√©essai √©chou√©: {retry_error}")
                        else:
                            failed_groups.add(group_id)
                            skipped += 1
                        
                        if on_progress:
                            on_progress(sent, total, skipped, failed_groups)
                    
                except Exception as e:
                    logger.error(f"Erreur inattendue {group_id}: {e}")
                    failed_groups.add(group_id)
                    skipped += 1
                    if on_progress:
                        on_progress(sent, total, skipped, failed_groups)
            
            # ‚úÖ Calculer les m√©triques de performance
            elapsed_time = time.time() - start_time
            messages_per_second = sent / elapsed_time if elapsed_time > 0 else 0
            success_rate = (sent / initial_total * 100) if initial_total > 0 else 0
            
            return sent, skipped, failed_groups
            
        finally:
            _rate_limiter.unregister_account(account_id)
    
    @staticmethod
    def _is_permission_error(error: str) -> bool:
        """V√©rifie si c'est une erreur de permission."""
        error_lower = error.lower()
        return any(x in error_lower for x in [
            "can't write", "topic_closed", "chat_write_forbidden", "permission"
        ])
    
    @staticmethod
    def _is_flood_error(error: str) -> bool:
        """V√©rifie si c'est une erreur de flood limit (fran√ßais et anglais)."""
        error_lower = error.lower()
        # D√©tection anglais : "wait X seconds"
        english_flood = 'wait' in error_lower and 'seconds' in error_lower
        # D√©tection fran√ßais : "attendez X secondes" ou "rate limit"
        french_flood = 'attendez' in error_lower and 'secondes' in error_lower
        rate_limit = 'rate limit' in error_lower
        
        return english_flood or french_flood or rate_limit
    
    @staticmethod
    def _extract_wait_time(error: str) -> int:
        """Extrait le temps d'attente d'une erreur de flood (fran√ßais et anglais)."""
        import re
        error_lower = error.lower()
        
        # Chercher en anglais : "wait 236 seconds"
        match = re.search(r'wait\s+(\d+)\s*seconds?', error_lower)
        if match:
            return int(match.group(1)) + 5
        
        # Chercher format alternatif anglais : "236 seconds"
        match = re.search(r'(\d+)\s*seconds?', error_lower)
        if match:
            return int(match.group(1)) + 5
        
        # Chercher en fran√ßais : "attendez 236 secondes"
        match = re.search(r'attendez\s+(\d+)\s*secondes?', error_lower)
        if match:
            return int(match.group(1)) + 5
        
        # Si rien trouv√©, d√©faut √† 60 secondes
        return 60
    
    @staticmethod
    def cleanup_temp_file(file_path: Optional[str]) -> None:
        """Nettoie un fichier temporaire."""
        if not file_path:
            return
        
        try:
            path = Path(file_path)
            if path.exists():
                path.unlink()
        except Exception as e:
            logger.error(f"Erreur nettoyage fichier: {e}")
